'use client';

import { useMemo, useState, useEffect, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { signIn } from 'next-auth/react';
import TopAreaSub from '@/component/top_area/TopAreaSub';
import { useToast } from '@/context/ToastContext';
import { uploadProfileImage, changeToBasicProfile } from '@/lib/api/storage';
import { updateNickname } from '@/lib/api/user';
import { submitConsents, ConsentPayload } from '@/lib/api/onboard';
import { fetchTerms, TermItem } from '@/lib/api/terms';
import StepIndicator from './StepIndicator';
import TermsStep from './TermsStep';
import NameStep from './NameStep';
import AccountStep from './AccountStep';
import ProfileStep from './ProfileStep';

const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d)(?=.*[!@#$%^&*()\-_=+[\]{\};:'",.<>/?]).{8,20}$/;

// 랜덤 닉네임 생성 함수
const adjectives = [
  '까칠한',
  '상냥한',
  '조용한',
  '엉뚱한',
  '활발한',
  '침착한',
  '용감한',
  '게으른',
  '차가운',
  '따뜻한',
  '느긋한',
  '솔직한',
  '냉철한',
  '귀여운',
  '시끄러운',
];

const animals = [
  '강아지',
  '고양이',
  '여우',
  '호랑이',
  '토끼',
  '펭귄',
  '부엉이',
  '돌고래',
  '하마',
  '다람쥐',
  '판다',
  '앵무새',
  '곰',
  '늑대',
  '고릴라',
];

function getRandomNickname() {
  const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
  const animal = animals[Math.floor(Math.random() * animals.length)];
  return `${adj} ${animal}`;
}

interface SignUpContentProps {
  initialTerms?: TermItem[];
}

export default function SignUpContent({ initialTerms = [] }: SignUpContentProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const forcedStep = searchParams.get('step');
  const isSNSFlow = forcedStep === '3';
  const { showToast } = useToast();

  const initialStep = useMemo(() => {
    if (isSNSFlow) return 4;
    const parsed = Number(forcedStep);
    if (parsed >= 1 && parsed <= 4) return parsed;
    return 1;
  }, [forcedStep, isSNSFlow]);

  const [currentStep, setCurrentStep] = useState(initialStep);
  // 서버에서 가져온 약관 데이터를 바로 사용 (서버에서 못 가져온 경우에만 클라이언트에서 업데이트)
  const [terms, setTerms] = useState<TermItem[]>(initialTerms);
  // 서버에서 이미 가져왔으므로 로딩 없음 (서버에서 못 가져온 경우에만 true)
  const [termsLoading, setTermsLoading] = useState(initialTerms.length === 0);
  const [termsAgreed, setTermsAgreed] = useState<Record<number, boolean>>(() => {
    // 초기 약관 동의 상태 설정
    const initialAgreed: Record<number, boolean> = {};
    initialTerms.forEach((term) => {
      initialAgreed[term.id] = false;
    });
    return initialAgreed;
  });
  const [nameValue, setNameValue] = useState('');
  const [nameError, setNameError] = useState('');

  const [accountLoading, setAccountLoading] = useState(false);
  const [accountErrors, setAccountErrors] = useState<{ email?: string; password?: string; confirm?: string; general?: string }>({});
  const [accountValues, setAccountValues] = useState<{ email: string; password: string; confirmPassword: string }>({
    email: '',
    password: '',
    confirmPassword: '',
  });
  const [accountSuccess, setAccountSuccess] = useState<{ email?: boolean; confirm?: boolean }>({});

  const [profileLoading, setProfileLoading] = useState(false);
  const [nicknameError, setNicknameError] = useState('');
  const [profilePreview, setProfilePreview] = useState<string | null>(null);
  const [profileFile, setProfileFile] = useState<File | null>(null);
  const [nickname, setNickname] = useState<string>('');
  const [autoGeneratedNickname, setAutoGeneratedNickname] = useState<string>('');
  const [autoGeneratedProfileNumber, setAutoGeneratedProfileNumber] = useState<1 | 2 | 3 | null>(null);

  // 서버에서 약관을 가져오지 못한 경우에만 클라이언트에서 재시도
  useEffect(() => {
    if (initialTerms.length > 0) {
      // 서버에서 이미 가져온 경우 아무것도 하지 않음
      return;
    }

    // 서버에서 가져오지 못한 경우에만 클라이언트에서 재시도
    let mounted = true;
    const loadTerms = async () => {
      try {
        setTermsLoading(true);
        const fetchedTerms = await fetchTerms();
        if (!mounted) return;
        
        setTerms(fetchedTerms);
        
        // 약관 동의 상태 초기화
        const initialAgreed: Record<number, boolean> = {};
        fetchedTerms.forEach((term) => {
          initialAgreed[term.id] = false;
        });
        setTermsAgreed(initialAgreed);
      } catch (err: any) {
        console.error('약관 목록 로드 실패:', err);
        showToast(err?.message ?? '약관 정보를 불러오는데 실패했습니다.');
      } finally {
        if (mounted) setTermsLoading(false);
      }
    };

    loadTerms();
    return () => {
      mounted = false;
    };
  }, [initialTerms.length, showToast]);

  // Step 4에 진입할 때 랜덤 닉네임과 프로필 이미지가 없으면 생성 (SNS 플로우 등)
  useEffect(() => {
    if (currentStep === 4 && !nickname && !autoGeneratedNickname) {
      const randomNickname = getRandomNickname();
      setAutoGeneratedNickname(randomNickname);
      setNickname(randomNickname);

      const randomProfileNumber = (Math.floor(Math.random() * 3) + 1) as 1 | 2 | 3;
      setAutoGeneratedProfileNumber(randomProfileNumber);
      setProfilePreview(`/profile_${randomProfileNumber}.png`);

      // 서버에 저장 (비동기로 처리 - SNS 플로우는 이미 로그인된 상태이므로)
      Promise.all([updateNickname(randomNickname), changeToBasicProfile(randomProfileNumber)]).catch((err) => {
        console.error('자동 프로필 설정 실패:', err);
      });
    }
  }, [currentStep, nickname, autoGeneratedNickname]);

  const validateAccountFields = useMemo(() => {
    const { email, password, confirmPassword } = accountValues;
    const errors: typeof accountErrors = {};
    const success: typeof accountSuccess = {};

    if (email) {
      if (!emailRegex.test(email)) {
        errors.email = '잘못된 이메일 형식입니다.';
      } else {
        success.email = true;
      }
    }

    if (password) {
      if (!passwordRegex.test(password)) {
        errors.password = '영문, 숫자, 특수문자를 포함한 8~20자로 입력해주세요.';
      }
    }

    if (confirmPassword) {
      if (password && password !== confirmPassword) {
        errors.confirm = '비밀번호가 일치하지 않습니다.';
      } else if (password && password === confirmPassword) {
        success.confirm = true;
      }
    }

    return {
      errors,
      success,
      isValid:
        Object.keys(errors).length === 0 &&
        email &&
        password &&
        confirmPassword &&
        password === confirmPassword &&
        emailRegex.test(email) &&
        passwordRegex.test(password),
    };
  }, [accountValues]);

  // 실시간 검증 결과를 상태에 반영
  useEffect(() => {
    if (accountValues.email || accountValues.password || accountValues.confirmPassword) {
      setAccountErrors(validateAccountFields.errors);
      setAccountSuccess(validateAccountFields.success);
    }
  }, [validateAccountFields, accountValues]);

  const toggleTerm = (id: number) => {
    setTermsAgreed((prev) => ({
      ...prev,
      [id]: !prev[id],
    }));
  };

  const allTermsChecked = useMemo(() => {
    if (!terms.length) return false;
    return terms.every((term) => termsAgreed[term.id]);
  }, [terms, termsAgreed]);

  const toggleAllTerms = () => {
    const next = !allTermsChecked;
    const updated: Record<number, boolean> = {};
    terms.forEach((term) => {
      updated[term.id] = next;
    });
    setTermsAgreed(updated);
  };

  const requiredTermsChecked = useMemo(() => {
    const requiredTerms = terms.filter((term) => term.isRequired);
    return requiredTerms.every((term) => termsAgreed[term.id]);
  }, [terms, termsAgreed]);

  const handleTermsNext = async () => {
    if (!requiredTermsChecked) {
      showToast('필수 약관에 동의해주세요.');
      return;
    }

    try {
      // 동의한 약관들을 ConsentPayload 형식으로 변환
      const consents: ConsentPayload[] = terms.filter((term) => termsAgreed[term.id]).map((term) => ({
        termsId: term.id,
      }));

      // 약관 동의를 서버에 전송
      await submitConsents(consents);
      setCurrentStep(2);
    } catch (err: any) {
      const message = err?.message ?? '약관 동의 처리에 실패했습니다.';
      showToast(message);
    }
  };

  const handleNameSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    const value = (formData.get('fullName') as string | null)?.trim() ?? '';
    if (!value) {
      setNameError('실명을 입력해주세요.');
      return;
    }
    setNameValue(value);
    setCurrentStep(3);
  };

  const handleAccountSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const { email, password, confirmPassword } = accountValues;

    if (!validateAccountFields.isValid) {
      setAccountErrors(validateAccountFields.errors);
      setAccountSuccess({});
      return;
    }

    setAccountLoading(true);
    setAccountErrors({});
    try {
      const res = await signIn('credentials', {
        redirect: false,
        email,
        password,
        name: nameValue,
      });

      if (res?.error) {
        setAccountErrors({ general: res.error });
        return;
      }

      // 회원가입 완료 후 자동으로 랜덤 닉네임과 프로필 이미지 설정
      const randomNickname = getRandomNickname();
      setAutoGeneratedNickname(randomNickname);
      setNickname(randomNickname);

      // 랜덤 프로필 이미지 선택 (1, 2, 3 중 하나)
      const randomProfileNumber = (Math.floor(Math.random() * 3) + 1) as 1 | 2 | 3;
      setAutoGeneratedProfileNumber(randomProfileNumber);

      // 프로필 이미지 미리보기 설정 (즉시 화면에 표시)
      setProfilePreview(`/profile_${randomProfileNumber}.png`);

      // 서버에 자동 생성된 닉네임과 프로필 이미지 저장 (완료 후 Step 4로 이동)
      try {
        await Promise.all([updateNickname(randomNickname), changeToBasicProfile(randomProfileNumber)]);
      } catch (err) {
        console.error('자동 프로필 설정 실패:', err);
        // 자동 설정 실패해도 회원가입은 계속 진행
      }

      // API 호출 완료 후 Step 4로 이동
      setCurrentStep(4);
    } finally {
      setAccountLoading(false);
    }
  };

  const handleProfileSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const finalNickname = nickname.trim();
    if (!finalNickname) {
      setNicknameError('닉네임을 입력해주세요.');
      return;
    }

    setProfileLoading(true);
    try {
      // 프로필 이미지가 변경된 경우에만 업로드
      if (profileFile) {
        await uploadProfileImage(profileFile);
      }
      // 닉네임이 변경된 경우에만 업데이트
      if (finalNickname !== autoGeneratedNickname) {
        await updateNickname(finalNickname);
      }
      showToast('프로필 정보가 저장되었습니다.');
      // 프로필 설정 완료 후 온보딩 페이지로 이동
      router.push('/onboard');
    } catch (err: any) {
      const message = err?.message ?? '프로필 저장에 실패했습니다.';
      setNicknameError(message);
      showToast(message);
    } finally {
      setProfileLoading(false);
    }
  };

  const handleBack = () => {
    if (currentStep === 1 || isSNSFlow) {
      router.push('/');
      return;
    }
    setCurrentStep((prev) => Math.max(1, prev - 1));
  };

  const handleProfileFileChange = (file: File | null) => {
    setProfileFile(file);
    if (file) {
      setProfilePreview(URL.createObjectURL(file));
    }
  };

  const renderStep = () => {
    if (currentStep === 1) {
      return (
        <TermsStep
          terms={terms}
          termsLoading={termsLoading}
          termsAgreed={termsAgreed}
          onToggleTerm={toggleTerm}
          onToggleAll={toggleAllTerms}
          onNext={handleTermsNext}
        />
      );
    }

    if (currentStep === 2) {
      return (
        <NameStep
          nameValue={nameValue}
          nameError={nameError}
          onNameChange={setNameValue}
          onNameErrorChange={setNameError}
          onSubmit={handleNameSubmit}
        />
      );
    }

    if (currentStep === 3) {
      return (
        <AccountStep
          accountValues={accountValues}
          accountErrors={accountErrors}
          accountSuccess={accountSuccess}
          accountLoading={accountLoading}
          onAccountChange={(field, value) => {
            setAccountValues((prev) => ({ ...prev, [field === 'confirmPassword' ? 'confirmPassword' : field]: value }));
          }}
          onSubmit={handleAccountSubmit}
        />
      );
    }

    return (
      <ProfileStep
        nickname={nickname}
        nicknameError={nicknameError}
        profilePreview={profilePreview}
        profileLoading={profileLoading}
        onNicknameChange={setNickname}
        onNicknameErrorChange={setNicknameError}
        onProfileFileChange={handleProfileFileChange}
        onSubmit={handleProfileSubmit}
      />
    );
  };

  return (
    <div className="flex flex-col items-center min-h-screen w-full bg-white">
      <div className="w-full flex flex-col">
        <TopAreaSub onBack={handleBack} />
        {renderStep()}
      </div>
    </div>
  );
}

